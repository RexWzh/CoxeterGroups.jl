var documenterSearchIndex = {"docs":
[{"location":"#CoxeterGroups.jl-Documentation","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"This package is for creating and working with Coxeter groups.","category":"page"},{"location":"#Creating-a-group","page":"CoxeterGroups.jl Documentation","title":"Creating a group","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"There are various implementations of Coxeter groups, each represented by a concrete type which is a subtype of the abstract CoxGrp. Use one of the constructors below to create a group, depending on which implementation is desired. For example:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"# A Coxeter group of type A2, implemented using minimal roots.\nW, (s, t) = coxter_group_min([2, -1; -1, 2])\n\n# The symmetric group S3, implemented via permutations.\nS, (u, v) = symmetric_group(3)","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Here is a summary of the creation functions - there is more information on specific implementations in the Implementations section.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"coxeter_group_min\nsymmetric_group\ncoxeter_group_recursive","category":"page"},{"location":"#CoxeterGroups.coxeter_group_min","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.coxeter_group_min","text":"coxeter_group_min(mat) -> CoxGrpMin, gens\n\nGiven a Coxeter matrix or GCM, create a Coxeter group implemented via the minimal roots automaton. Currently only a GCM can be passed.\n\n\n\n\n\n","category":"function"},{"location":"#CoxeterGroups.symmetric_group","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.symmetric_group","text":"symmetric_group(n) -> CoxGrpSym, gens\n\nCreate the symmetric group on n elements (a Coxeter system of type A_n-1), for n geq 0.\n\n\n\n\n\n","category":"function"},{"location":"#CoxeterGroups.coxeter_group_recursive","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.coxeter_group_recursive","text":"coxeter_group_recursive(M, [names])\n\nCreate a Coxeter group with elements represented in InverseShortLex normal form, with group operations implemented with a recursive algorithm.\n\n\n\n\n\ncoxeter_group_recursive(groupType::String)\n\nCreate a Coxeter Group based on one or more group type strings. To denote the direct product of group types, enter the group types seperated by the 'x' character. Affine groups are denoted by including a '~' character after a letter.\n\n#Examples\n\njulia> CG, _ = coxeter_group_recursive(\"A3\")\n(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [\"<1>\", \"<2>\", \"<3>\"]), CoxEltRec[CoxEltRec(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [\"<1>\", \"<2>\", \"<3>\"]), [1]), CoxEltRec(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [\"<1>\", \"<2>\", \"<3>\"]), [2]), CoxEltRec(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [\"<1>\", \"<2>\", \"<3>\"]), [3])])\n\njulia> CG\nCoxeter Group with Coxeter Matrix:\n3×3 Matrix{Int64}:\n 1  3  2\n 3  1  3\n 2  3  1\nand generating Set:\n[\"<1>\", \"<2>\", \"<3>\"]\n\n\njulia> CG, _ = coxeter_group_recursive(\"A3 x B4\")\n[1 3 2; 3 1 3; 2 3 1]\n[1 3 2 2; 3 1 3 2; 2 3 1 4; 2 2 4 1]\n(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), CoxEltRec[CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), [1]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), [2]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), [3]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), [4]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), [5]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), [6]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]), [7])])\n\njulia> CG\nCoxeter Group with Coxeter Matrix:\n7×7 Matrix{Int64}:\n 1  3  2  2  2  2  2\n 3  1  3  2  2  2  2\n 2  3  1  2  2  2  2\n 2  2  2  1  3  2  2\n 2  2  2  3  1  3  2\n 2  2  2  2  3  1  4\n 2  2  2  2  2  4  1\nand generating Set:\n[\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\", \"<6>\", \"<7>\"]\n\n\njulia> CG, _ = coxeter_group_recursive(\"D~4\")\n(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\"]), CoxEltRec[CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\"]), [1]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\"]), [2]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\"]), [3]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\"]), [4]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\"]), [5])])\n\njulia> CG\nCoxeter Group with Coxeter Matrix:\n5×5 Matrix{Int64}:\n 1  2  3  2  2\n 2  1  3  2  2\n 3  3  1  3  3\n 2  2  3  1  2\n 2  2  3  2  1\nand generating Set:\n[\"<1>\", \"<2>\", \"<3>\", \"<4>\", \"<5>\"]\n\n\n\n\n\n\n","category":"function"},{"location":"#Operations-on-the-group","page":"CoxeterGroups.jl Documentation","title":"Operations on the group","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A Coxeter group is a subtype of the abstract CoxGrp type. Coxeter groups compare equal by reference. The following operations are supported on all group implementations:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"CoxeterGroups.rank(::CoxGrpMin)\nCoxeterGroups.generators(::CoxGrpMin)\nBase.one(::CoxGrpMin)\nCoxeterGroups.coxeter_matrix(::CoxGrpMin)\nCoxeterGroups.is_finite(::CoxGrpMin)\nCoxeterGroups.longest_element(::CoxGrp)","category":"page"},{"location":"#CoxeterGroups.rank-Tuple{CoxGrpMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.rank","text":"rank(W::CoxGrp) -> Integer\n\nReturn the rank (number of generators) of the Coxeter group.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.generators-Tuple{CoxGrpMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.generators","text":"generators(W::CoxGrp)\n\nReturn the simple generators of W.\n\n\n\n\n\n","category":"method"},{"location":"#Base.one-Tuple{CoxGrpMin}","page":"CoxeterGroups.jl Documentation","title":"Base.one","text":"one(W::CoxGrp) -> CoxElt\n\nReturn the identity in the Coxeter group W.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.coxeter_matrix-Tuple{CoxGrpMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.coxeter_matrix","text":"coxeter_matrix(W::CoxGrp) -> Matrix\n\nReturn the Coxeter matrix for this group.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.is_finite-Tuple{CoxGrpMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.is_finite","text":"is_finite(W::CoxGrp) -> Bool\n\nReturn whether the group W is finite or not.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.longest_element-Tuple{CoxGrp}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.longest_element","text":"longest_element(W::CoxGrp)\n\nReturn the longest element if W is finite, otherwise error.\n\n\n\n\n\n","category":"method"},{"location":"#Operations-on-group-elements","page":"CoxeterGroups.jl Documentation","title":"Operations on group elements","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A Coxeter group element is a subtype of the abstract CoxElt type. Coxeter group elements are immutable value types: they compare equal if they represent the same group element, they can be used as keys in hash tables, and so on. The following operations are supported on all Coxeter group element implementations:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Base.parent(::CoxEltMin)\nBase.isone(::CoxEltMin)\nBase.:(*)(::CoxEltMin, ::CoxEltMin)\nBase.inv(::CoxEltMin)\nBase.:(^)(::CoxElt, ::Integer)\nCoxeterGroups.length(::CoxEltMin)\nBase.sign(::CoxElt)\nCoxeterGroups.is_right_descent(::CoxEltMin, ::Integer)\nCoxeterGroups.is_left_descent(::Integer, ::CoxEltMin)\nCoxeterGroups.right_multiply(::CoxEltMin, ::Integer)\nCoxeterGroups.left_multiply(::Integer, ::CoxEltMin)\nCoxeterGroups.short_lex(::CoxEltMin)\nCoxeterGroups.inverse_short_lex(::CoxEltMin)","category":"page"},{"location":"#Base.parent-Tuple{CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"Base.parent","text":"parent(w::CoxElt) -> CoxGrp\n\nReturn the parent group of W.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isone-Tuple{CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"Base.isone","text":"isone(w::CoxElt) -> Bool\n\nCheck if w is the identity of the group.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:*-Tuple{CoxEltMin, CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"Base.:*","text":"*(w, x)\n\nThe product wx of Coxeter group elements.\n\n\n\n\n\n","category":"method"},{"location":"#Base.inv-Tuple{CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"Base.inv","text":"inv(w)\n\nThe inverse w^-1 of a Coxeter group element.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:^-Tuple{CoxElt, Integer}","page":"CoxeterGroups.jl Documentation","title":"Base.:^","text":"^(x::CoxElt, e::T) where T <: Integer\n\nReturn the power x^e.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"Base.length","text":"length(w::CoxElt) -> Integer\n\nThe length of the group element w, i.e. the number of generators in any reduced expression for w.\n\n\n\n\n\n","category":"method"},{"location":"#Base.sign-Tuple{CoxElt}","page":"CoxeterGroups.jl Documentation","title":"Base.sign","text":"sign(w::CoxElt) -> Int\n\nThe sign homomorphism (-1)^l(w).\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.is_right_descent-Tuple{CoxEltMin, Integer}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.is_right_descent","text":"is_right_descent(w::CoxElt, t::Integer) -> Bool\n\nReturn true if t is a right descent of w, i.e. if l(wt)  l(w).\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.is_left_descent-Tuple{Integer, CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.is_left_descent","text":"is_left_descent(t::Integer, w::CoxElt) -> Bool\n\nReturn true if t is a left descent of w, i.e. if l(tw)  l(w).\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.right_multiply-Tuple{CoxEltMin, Integer}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.right_multiply","text":"right_multiply(w::CoxElt, s::Integer) -> CoxElt\n\nReturn the product ws, where s is the simple reflection indexed by s.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.left_multiply-Tuple{Integer, CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.left_multiply","text":"left_multiply(s::Integer, w::CoxElt) -> CoxElt\n\nReturn the product sw, where s is the simple reflection indexed by s.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.short_lex-Tuple{CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.short_lex","text":"short_lex(w::CoxElt) -> Vector{Int8}\n\nReturn the ShortLex normal form of w, meaning the lexicographically least reduced expression.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.inverse_short_lex-Tuple{CoxEltMin}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.inverse_short_lex","text":"inverse_short_lex(w)\n\nReturn the InverseShortLex normal form of w: the lexicographically least reduced expression for w when read backwards, or equivalently the reverse of the ShortLex normal form of w^-1.\n\n\n\n\n\n","category":"method"},{"location":"#Internals","page":"CoxeterGroups.jl Documentation","title":"Internals","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A Coxeter group implementation consists of a new pair of concrete types subtyping CoxGrp and CoxElt respectively.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"CoxGrp\nCoxElt","category":"page"},{"location":"#CoxeterGroups.CoxGrp","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.CoxGrp","text":"The abstract supertype for Coxeter groups.\n\n\n\n\n\n","category":"type"},{"location":"#CoxeterGroups.CoxElt","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.CoxElt","text":"The abstract supertype for Coxeter group elements.\n\n\n\n\n\n","category":"type"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"When adding a new concrete implementation, a small set of functions must be implemented explicitly, then generic implementations of other functions will begin working. The concrete implementation should specialise these generic implementations where it is possible to take advantage of specific internal structure.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"The group type must implement a constructor such as those in Creating a group, and the functions coxeter_matrix rank, one, generators, and is_finite.\nThe element type must implement parent, ==, hash, is_left_descent, is_right_descent, left_multiply, and right_multiply.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"The following functions will then be defined:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"For the group type: longest_element.\nFor the element type: isone, length, sign, short_lex, inverse_short_lex, *, inv, ^.","category":"page"},{"location":"#Code-conventions","page":"CoxeterGroups.jl Documentation","title":"Code conventions","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Code conventions are (currently) as follows:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Library users should access data via methods, not via properties.\nA Coxeter group implementation called foo should define a concrete subtype CoxGrpFoo of CoxGrp, and a concrete subtype CoxEltFoo of CoxElt.","category":"page"},{"location":"#Mathematical-conventions","page":"CoxeterGroups.jl Documentation","title":"Mathematical conventions","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A generalised Cartan matrix or GCM is a square matrix A in operatornameMat_I(mathbbZ) over the integers which satisfies the following properties:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"(C1) All diagonal elements are equal to 2,\n(C2) All off-diagonal entries are zero or negative, and\n(C3) A_ij = 0 if and only if A_ji = 0.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A Coxeter-Cartan matrix is a square matrix A over the reals which satisfies the conditions C1, C2, C3 of a GCM, and additionally","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"(C4) The product A_ij A_ji is either equal to 4 cos^2(pim) for some m in 2 3 ldots, or A_ij A_ji geq 4.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A based root datum over the PID R (we will only be thinking of R = mathbbZ or R = mathbbR) is the data of:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Two free R-modules X and X^vee,\nA perfect pairing langle - - rangle colon X^vee times X to R,\nA collection of simple roots Delta = alpha_i_i in I in X,\nA collection of simple coroots Delta^vee = alpha_i^vee_i in I in X^vee,","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"such that the matrix A_ij = langle alpha_i^vee alpha_j rangle is a GCM. We then say that the based root datum is a realisation of the GCM A. Define the reflections r_i colon X to X and r_i^vee colon X^vee to X^vee by the formulas","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"r_i(lambda) = lambda - langle alpha_i^vee lambda rangle alpha_i quad\nr_i^vee(nu) = nu - langle nu alpha_i rangle alpha_i^vee","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Then the reflections each define a faithful representation of a Coxeter group (W I) on each of X and X^vee, which are dual in the sense that langle w nu lambda rangle = langle nu w lambda rangle.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Every GCM A admits two canonical based root data. The simply-connected realisation is the root datum where X^vee is the free R-module with basis (alpha_i^vee)_i in I, X = operatornameHom(X^vee R) is the dual, the pairing langle - - rangle is the canonical pairing between a module and its dual, and the simple roots alpha_i are uniquely determined by the condition that langle alpha_i^vee alpha_j rangle = A_ij. The adjoint realisation is the dual of the simply-connected realisation.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"In the reflection representation implementation, we use the adjoint realisation of a GCM. Concretely, the space X is the space of column vectors, with each simple root alpha_i a coordinate vector, the space X^vee is the space of row vectors, with each simple coroot alpha_i^vee equal to the ith row of the Cartan matrix, and the pairing langle - - rangle is the dot product.","category":"page"},{"location":"#Implementations","page":"CoxeterGroups.jl Documentation","title":"Implementations","text":"","category":"section"},{"location":"#Minimal-roots-implementation","page":"CoxeterGroups.jl Documentation","title":"Minimal roots implementation","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"The minimal roots implementation of a Coxeter group represents group elements by words in the Coxeter generators in ShortLex normal form. Operations on these words are done with the assistance of a minimal root reflection table, which needs to be constructed when the group is created.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Currently this implementation can handle any Coxeter group defined by a generalised Cartan matrix, but this is only because generating the minimal root reflection table is more difficult for general Coxeter groups. The same underlying algorithms will work once given a new table.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Performance characteristics for a Coxeter group of rank r:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"The group itself takes O(r M) space, where M is the number of minimal roots. For finite types, the minimal roots are exactly the positive roots, and for affine types, there are twice as many minimal roots as there are positive roots for the corresponding finite system. The number of roots in a finite system tends to be O(r^2) in the rank r.\nLength is an O(1) operation.\nShortLex normal form should be O(1), but is O(l(w)) since it returns a defensive copy of the internal word.\nTesting a left or right descent is O(l(w)).\nMultiplication on the right xs by a simple generator s is O(l(x)).\nMultiplication on the left sx by a simple generator s is O(l(x)^2).\nMultiplication xy is O(l(y)(l(x) + l(y))).\nInversion x^-1 is O(l(x)^2).","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"CoxGrpMin\nCoxeterGroups.create_reflection_table_gcm","category":"page"},{"location":"#CoxeterGroups.CoxGrpMin","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.CoxGrpMin","text":"A Coxeter group, implemented using the minimal root reflection table.\n\n\n\n\n\n","category":"type"},{"location":"#CoxeterGroups.create_reflection_table_gcm","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.create_reflection_table_gcm","text":"create_reflection_table_gcm(gcm)\n\nCreate the minimal root reflection table for a Coxeter group defined by a GCM (generalised Cartan matrix). This is a straightforward algorithm since we need only deal with integers, rather than algebraic integers.\n\nThe return value is a matrix refl_table of size R×T, where R is the rank of the group (the size of the square GCM), and T is the number of minimal roots. The minimal roots are indexed from 1:T, with the first 1:R of them corresponding to the simple roots, and the other indices arbitrary.\n\nIf β = s(α) is a minimal root, then refl_table[s, α] stores the index of β, and otherwise refl_table[s, α] = 0. Note that refl_table[s, s] = 0 for every simple root s.\n\n\n\n\n\n","category":"function"},{"location":"#Symmetric-groups","page":"CoxeterGroups.jl Documentation","title":"Symmetric groups","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"The symmetric group S_n on n letters is the group of permutations of the set n = 1 ldots n, whose standard Coxeter generators are s_1 ldots s_n-1 where s_i = (i i+1) is an adjacent transposition. The symmetric group may be constructed using the symmetric_group function.","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A permutation pi colon n to n is represented as a pair of arrays recording both pi and its inverse pi^-1:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"    pi mapsto (mathttfwd = pi(1) ldots pi(n) mathttinv = pi^-1(1) ldots pi^-1(n))","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Complexity of operations in terms of n:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Creation of the group is O(1).\nMemory usage for each element is O(n).\nTesting a left or right descent is O(1).\nMultiplication is O(n).\nCalculating the sign of a permutation is O(n)\nTaking Coxeter length takes O(n^2) time (this could be improved to O(n log n) by a standard divide-and-conquer trick to count inversions).","category":"page"},{"location":"#Creating-Coxeter-systems","page":"CoxeterGroups.jl Documentation","title":"Creating Coxeter systems","text":"","category":"section"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"A Coxeter system is an object which stores a Coxeter matrix along with a classification into components of known type. Currently all finite and affine type components are classified, but anything indefinite (hyperbolic or otherwise) will be classified as Unknown type. Some properties of finite-type Coxeter systems can be inferred entirely from this classification, without having to construct a group object at all. For instance:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"using CoxeterGroups\ngcm = [\n     2  -1   0   0\n    -1   2  -1   0\n     0  -2   2   0\n     0   0   0   2\n]\ncox = coxeter_system(gcm)\ncox","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"Data known purely by classification can then be queried:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"rank(cox), coxeter_name(cox), number_of_reflections(cox), order(cox)","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"The construction methods and information methods that work with Coxeter systems is below:","category":"page"},{"location":"","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.jl Documentation","text":"coxeter_system\ncoxeter_name(::CoxeterSystem)\nrank(::CoxeterSystem)\nis_irreducible(::CoxeterSystem)\nis_finite_type(::CoxeterSystem)\nis_affine_type(::CoxeterSystem)\norder(::CoxeterSystem)\ncoxeter_number(::CoxeterSystem)\nnumber_of_reflections(::CoxeterSystem)\ndegrees(::CoxeterSystem)\nexponents(::CoxeterSystem)","category":"page"},{"location":"#CoxeterGroups.coxeter_system","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.coxeter_system","text":"coxeter_system(mat)\n\nCreate a Coxeter system from a Coxeter matrix or Cartan matrix.\n\n\n\n\n\n","category":"function"},{"location":"#CoxeterGroups.coxeter_name-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.coxeter_name","text":"coxeter_name(cox::CoxeterSystem)\n\nA string representing the type of the system, such as \"H3 x A2\".\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.rank-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.rank","text":"rank(cox::CoxeterSystem)\n\nThe rank of a Coxeter system (W S) is the number S of simple generators.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.is_irreducible-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.is_irreducible","text":"is_irreducible(cox::CoxeterSystem)\n\nA Coxeter system (W S) is irreducible if its associated underyling graph consists of a single connected component. In particular, S  1.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.is_finite_type-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.is_finite_type","text":"is_finite_type(cox::CoxeterSystem)\n\nA Coxeter system (W S) is finite type if the group W is finite.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.is_affine_type-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.is_affine_type","text":"is_affine_type(cox::CoxeterSystem)\n\nA Coxeter system (W S) is affine type if is irreducible, and the unique component is of affine type.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.order-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.order","text":"order(cox::CoxeterSystem)\n\nThe order of a Coxeter system (W S) is the order of the group W. Throws an error if the system is not finite type.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.coxeter_number-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.coxeter_number","text":"coxeter_number(cox::CoxeterSystem)\n\nThe Coxeter number h of an irreducible Coxeter system (W S) is the order of any Coxeter element (product of all simple reflections), or 2 Φ^+  S, or the largest degree d_S. If the Coxeter system is not irreducible then these definitions all diverge, so this function will throw an error on a reducible system.\n\nThrows an error if the system is reducible or not of finite type.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.number_of_reflections-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.number_of_reflections","text":"number_of_reflections(cox::CoxeterSystem)\n\nThe number of reflections in a Coxeter system (W S) is the number of conjugates of the simple generators S, or equivalently the number of roots in a root system for W. Throws an error if the system is not finite type.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.degrees-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.degrees","text":"degrees(cox::CoxeterSystem)\n\nThe degrees d_1    d_r of a Coxeter system (W S) are the degrees of the fundamental invariants for the action of W on operatornameSym(V^*), where V is an irreducible representation of W with S acting by reflections. Throws an error if the system is not finite type.\n\n\n\n\n\n","category":"method"},{"location":"#CoxeterGroups.exponents-Tuple{CoxeterSystem}","page":"CoxeterGroups.jl Documentation","title":"CoxeterGroups.exponents","text":"exponents(cox::CoxeterSystem)\n\nThe exponents m_1    m_r of a Coxeter system (W S) describe the eigenvalues (with multiplicity) of a Coxeter element acting on the Tits representation V, which are roots of unity exp(2 pi i m_i  h) where h is the Coxeter number. Throws an error if the system is not finite type.\n\n\n\n\n\n","category":"method"}]
}
