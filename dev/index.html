<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CoxeterGroups.jl Documentation · CoxeterGroups.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CoxeterGroups.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>CoxeterGroups.jl Documentation</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-group"><span>Creating a group</span></a></li><li><a class="tocitem" href="#Operations-on-the-group"><span>Operations on the group</span></a></li><li><a class="tocitem" href="#Operations-on-group-elements"><span>Operations on group elements</span></a></li><li><a class="tocitem" href="#Internals"><span>Internals</span></a></li><li><a class="tocitem" href="#Code-conventions"><span>Code conventions</span></a></li><li><a class="tocitem" href="#Mathematical-conventions"><span>Mathematical conventions</span></a></li><li><a class="tocitem" href="#Implementations"><span>Implementations</span></a></li><li><a class="tocitem" href="#Creating-Coxeter-systems"><span>Creating Coxeter systems</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CoxeterGroups.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CoxeterGroups.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CoxeterGroups.jl-Documentation"><a class="docs-heading-anchor" href="#CoxeterGroups.jl-Documentation">CoxeterGroups.jl Documentation</a><a id="CoxeterGroups.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CoxeterGroups.jl-Documentation" title="Permalink"></a></h1><p>This package is for creating and working with Coxeter groups.</p><h2 id="Creating-a-group"><a class="docs-heading-anchor" href="#Creating-a-group">Creating a group</a><a id="Creating-a-group-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-group" title="Permalink"></a></h2><p>There are various implementations of Coxeter groups, each represented by a concrete type which is a subtype of the abstract <a href="#CoxeterGroups.CoxGrp"><code>CoxGrp</code></a>. Use one of the constructors below to create a group, depending on which implementation is desired. For example:</p><pre><code class="language-julia hljs"># A Coxeter group of type A2, implemented using minimal roots.
W, (s, t) = coxter_group_min([2, -1; -1, 2])

# The symmetric group S3, implemented via permutations.
S, (u, v) = symmetric_group(3)</code></pre><p>Here is a summary of the creation functions - there is more information on specific implementations in the <a href="#Implementations">Implementations</a> section.</p><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.coxeter_group_min" href="#CoxeterGroups.coxeter_group_min"><code>CoxeterGroups.coxeter_group_min</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coxeter_group_min(mat) -&gt; CoxGrpMin, gens</code></pre><p>Given a Coxeter matrix or GCM, create a Coxeter group implemented via the minimal roots automaton. Currently only a GCM can be passed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.symmetric_group" href="#CoxeterGroups.symmetric_group"><code>CoxeterGroups.symmetric_group</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">symmetric_group(n) -&gt; CoxGrpSym, gens</code></pre><p>Create the symmetric group on <span>$n$</span> elements (a Coxeter system of type <span>$A_{n-1}$</span>), for <span>$n \geq 0$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpSym.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.coxeter_group_recursive" href="#CoxeterGroups.coxeter_group_recursive"><code>CoxeterGroups.coxeter_group_recursive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coxeter_group_recursive(M, [names])</code></pre><p>Create a Coxeter group with elements represented in InverseShortLex normal form, with group operations implemented with a recursive algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpRec.jl#L35-L40">source</a></section><section><div><pre><code class="nohighlight hljs">coxeter_group_recursive(groupType::String)</code></pre><p>Create a Coxeter Group based on one or more group type strings. To denote the direct product of group types, enter the group types seperated by the &#39;x&#39; character. Affine groups are denoted by including a &#39;~&#39; character after a letter.</p><p>#Examples</p><pre><code class="language-julia-repl hljs">julia&gt; CG, _ = coxeter_group_recursive(&quot;A3&quot;)
(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;]), CoxEltRec[CoxEltRec(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;]), [1]), CoxEltRec(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;]), [2]), CoxEltRec(CoxGrpRec([1 3 2; 3 1 3; 2 3 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;]), [3])])

julia&gt; CG
Coxeter Group with Coxeter Matrix:
3×3 Matrix{Int64}:
 1  3  2
 3  1  3
 2  3  1
and generating Set:
[&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;]
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; CG, _ = coxeter_group_recursive(&quot;A3 x B4&quot;)
[1 3 2; 3 1 3; 2 3 1]
[1 3 2 2; 3 1 3 2; 2 3 1 4; 2 2 4 1]
(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), CoxEltRec[CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), [1]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), [2]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), [3]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), [4]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), [5]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), [6]), CoxEltRec(CoxGrpRec([1 3 … 2 2; 3 1 … 2 2; … ; 2 2 … 1 4; 2 2 … 4 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]), [7])])

julia&gt; CG
Coxeter Group with Coxeter Matrix:
7×7 Matrix{Int64}:
 1  3  2  2  2  2  2
 3  1  3  2  2  2  2
 2  3  1  2  2  2  2
 2  2  2  1  3  2  2
 2  2  2  3  1  3  2
 2  2  2  2  3  1  4
 2  2  2  2  2  4  1
and generating Set:
[&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;, &quot;&lt;6&gt;&quot;, &quot;&lt;7&gt;&quot;]
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; CG, _ = coxeter_group_recursive(&quot;D~4&quot;)
(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;]), CoxEltRec[CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;]), [1]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;]), [2]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;]), [3]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;]), [4]), CoxEltRec(CoxGrpRec([1 2 … 2 2; 2 1 … 2 2; … ; 2 2 … 1 2; 2 2 … 2 1], [&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;]), [5])])

julia&gt; CG
Coxeter Group with Coxeter Matrix:
5×5 Matrix{Int64}:
 1  2  3  2  2
 2  1  3  2  2
 3  3  1  3  3
 2  2  3  1  2
 2  2  3  2  1
and generating Set:
[&quot;&lt;1&gt;&quot;, &quot;&lt;2&gt;&quot;, &quot;&lt;3&gt;&quot;, &quot;&lt;4&gt;&quot;, &quot;&lt;5&gt;&quot;]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpRec.jl#L56-L114">source</a></section></article><h2 id="Operations-on-the-group"><a class="docs-heading-anchor" href="#Operations-on-the-group">Operations on the group</a><a id="Operations-on-the-group-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-the-group" title="Permalink"></a></h2><p>A Coxeter group is a subtype of the abstract <a href="#CoxeterGroups.CoxGrp"><code>CoxGrp</code></a> type. Coxeter groups compare equal by reference. The following operations are supported on all group implementations:</p><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.rank-Tuple{CoxGrpMin}" href="#CoxeterGroups.rank-Tuple{CoxGrpMin}"><code>CoxeterGroups.rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(W::CoxGrp) -&gt; Integer</code></pre><p>Return the rank (number of generators) of the Coxeter group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.generators-Tuple{CoxGrpMin}" href="#CoxeterGroups.generators-Tuple{CoxGrpMin}"><code>CoxeterGroups.generators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generators(W::CoxGrp)</code></pre><p>Return the simple generators of <span>$W$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.one-Tuple{CoxGrpMin}" href="#Base.one-Tuple{CoxGrpMin}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">one(W::CoxGrp) -&gt; CoxElt</code></pre><p>Return the identity in the Coxeter group <span>$W$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L81-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.coxeter_matrix-Tuple{CoxGrpMin}" href="#CoxeterGroups.coxeter_matrix-Tuple{CoxGrpMin}"><code>CoxeterGroups.coxeter_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coxeter_matrix(W::CoxGrp) -&gt; Matrix</code></pre><p>Return the Coxeter matrix for this group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.is_finite-Tuple{CoxGrpMin}" href="#CoxeterGroups.is_finite-Tuple{CoxGrpMin}"><code>CoxeterGroups.is_finite</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_finite(W::CoxGrp) -&gt; Bool</code></pre><p>Return whether the group <span>$W$</span> is finite or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L95-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.longest_element-Tuple{CoxGrp}" href="#CoxeterGroups.longest_element-Tuple{CoxGrp}"><code>CoxeterGroups.longest_element</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">longest_element(W::CoxGrp)</code></pre><p>Return the longest element if <span>$W$</span> is finite, otherwise error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterGroups.jl#L164-L167">source</a></section></article><h2 id="Operations-on-group-elements"><a class="docs-heading-anchor" href="#Operations-on-group-elements">Operations on group elements</a><a id="Operations-on-group-elements-1"></a><a class="docs-heading-anchor-permalink" href="#Operations-on-group-elements" title="Permalink"></a></h2><p>A Coxeter group element is a subtype of the abstract <a href="#CoxeterGroups.CoxElt"><code>CoxElt</code></a> type. Coxeter group elements are immutable value types: they compare equal if they represent the same group element, they can be used as keys in hash tables, and so on. The following operations are supported on all Coxeter group element implementations:</p><article class="docstring"><header><a class="docstring-binding" id="Base.parent-Tuple{CoxEltMin}" href="#Base.parent-Tuple{CoxEltMin}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent(w::CoxElt) -&gt; CoxGrp</code></pre><p>Return the parent group of <span>$W$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isone-Tuple{CoxEltMin}" href="#Base.isone-Tuple{CoxEltMin}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isone(w::CoxElt) -&gt; Bool</code></pre><p>Check if <span>$w$</span> is the identity of the group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{CoxEltMin, CoxEltMin}" href="#Base.:*-Tuple{CoxEltMin, CoxEltMin}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(w, x)</code></pre><p>The product <span>$wx$</span> of Coxeter group elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L261-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{CoxEltMin}" href="#Base.inv-Tuple{CoxEltMin}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(w)</code></pre><p>The inverse <span>$w^{-1}$</span> of a Coxeter group element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L303-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{CoxElt, Integer}" href="#Base.:^-Tuple{CoxElt, Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">^(x::CoxElt, e::T) where T &lt;: Integer</code></pre><p>Return the power <span>$x^e$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterGroups.jl#L138-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{CoxEltMin}" href="#Base.length-Tuple{CoxEltMin}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(w::CoxElt) -&gt; Integer</code></pre><p>The length of the group element <span>$w$</span>, i.e. the number of generators in any reduced expression for <span>$w$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sign-Tuple{CoxElt}" href="#Base.sign-Tuple{CoxElt}"><code>Base.sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sign(w::CoxElt) -&gt; Int</code></pre><p>The sign homomorphism <span>$(-1)^{l(w)}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterGroups.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.is_right_descent-Tuple{CoxEltMin, Integer}" href="#CoxeterGroups.is_right_descent-Tuple{CoxEltMin, Integer}"><code>CoxeterGroups.is_right_descent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_right_descent(w::CoxElt, t::Integer) -&gt; Bool</code></pre><p>Return true if <span>$t$</span> is a right descent of <span>$w$</span>, i.e. if <span>$l(wt) &lt; l(w)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.is_left_descent-Tuple{Integer, CoxEltMin}" href="#CoxeterGroups.is_left_descent-Tuple{Integer, CoxEltMin}"><code>CoxeterGroups.is_left_descent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_left_descent(t::Integer, w::CoxElt) -&gt; Bool</code></pre><p>Return true if <span>$t$</span> is a left descent of <span>$w$</span>, i.e. if <span>$l(tw) &lt; l(w)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.right_multiply-Tuple{CoxEltMin, Integer}" href="#CoxeterGroups.right_multiply-Tuple{CoxEltMin, Integer}"><code>CoxeterGroups.right_multiply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">right_multiply(w::CoxElt, s::Integer) -&gt; CoxElt</code></pre><p>Return the product <span>$ws$</span>, where <span>$s$</span> is the simple reflection indexed by <span>$s$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L280-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.left_multiply-Tuple{Integer, CoxEltMin}" href="#CoxeterGroups.left_multiply-Tuple{Integer, CoxEltMin}"><code>CoxeterGroups.left_multiply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">left_multiply(s::Integer, w::CoxElt) -&gt; CoxElt</code></pre><p>Return the product <span>$sw$</span>, where <span>$s$</span> is the simple reflection indexed by <span>$s$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L292-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.short_lex-Tuple{CoxEltMin}" href="#CoxeterGroups.short_lex-Tuple{CoxEltMin}"><code>CoxeterGroups.short_lex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">short_lex(w::CoxElt) -&gt; Vector{Int8}</code></pre><p>Return the <code>ShortLex</code> normal form of <span>$w$</span>, meaning the lexicographically least reduced expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.inverse_short_lex-Tuple{CoxEltMin}" href="#CoxeterGroups.inverse_short_lex-Tuple{CoxEltMin}"><code>CoxeterGroups.inverse_short_lex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_short_lex(w)</code></pre><p>Return the InverseShortLex normal form of <code>w</code>: the lexicographically least reduced expression for <span>$w$</span> when read backwards, or equivalently the reverse of the ShortLex normal form of <span>$w^{-1}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterGroups.jl#L91-L96">source</a></section></article><h2 id="Internals"><a class="docs-heading-anchor" href="#Internals">Internals</a><a id="Internals-1"></a><a class="docs-heading-anchor-permalink" href="#Internals" title="Permalink"></a></h2><p>A Coxeter group implementation consists of a new pair of concrete types subtyping <a href="#CoxeterGroups.CoxGrp"><code>CoxGrp</code></a> and <a href="#CoxeterGroups.CoxElt"><code>CoxElt</code></a> respectively.</p><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.CoxGrp" href="#CoxeterGroups.CoxGrp"><code>CoxeterGroups.CoxGrp</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The abstract supertype for Coxeter groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterGroups.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.CoxElt" href="#CoxeterGroups.CoxElt"><code>CoxeterGroups.CoxElt</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The abstract supertype for Coxeter group elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterGroups.jl#L16">source</a></section></article><p>When adding a new concrete implementation, a small set of functions must be implemented explicitly, then generic implementations of other functions will begin working. The concrete implementation should specialise these generic implementations where it is possible to take advantage of specific internal structure.</p><ul><li>The group type must implement a constructor such as those in <a href="#Creating-a-group">Creating a group</a>, and the functions <a href="#CoxeterGroups.coxeter_matrix-Tuple{CoxGrpMin}"><code>coxeter_matrix</code></a> <a href="#CoxeterGroups.rank-Tuple{CoxGrpMin}"><code>rank</code></a>, <a href="#Base.one-Tuple{CoxGrpMin}"><code>one</code></a>, <a href="#CoxeterGroups.generators-Tuple{CoxGrpMin}"><code>generators</code></a>, and <a href="#CoxeterGroups.is_finite-Tuple{CoxGrpMin}"><code>is_finite</code></a>.</li><li>The element type must implement <a href="#Base.parent-Tuple{CoxEltMin}"><code>parent</code></a>, <code>==</code>, <code>hash</code>, <a href="#CoxeterGroups.is_left_descent-Tuple{Integer, CoxEltMin}"><code>is_left_descent</code></a>, <a href="#CoxeterGroups.is_right_descent-Tuple{CoxEltMin, Integer}"><code>is_right_descent</code></a>, <a href="#CoxeterGroups.left_multiply-Tuple{Integer, CoxEltMin}"><code>left_multiply</code></a>, and <a href="#CoxeterGroups.right_multiply-Tuple{CoxEltMin, Integer}"><code>right_multiply</code></a>.</li></ul><p>The following functions will then be defined:</p><ul><li>For the group type: <a href="#CoxeterGroups.longest_element-Tuple{CoxGrp}"><code>longest_element</code></a>.</li><li>For the element type: <a href="#Base.isone-Tuple{CoxEltMin}"><code>isone</code></a>, <a href="#Base.length-Tuple{CoxEltMin}"><code>length</code></a>, <a href="#Base.sign-Tuple{CoxElt}"><code>sign</code></a>, <a href="#CoxeterGroups.short_lex-Tuple{CoxEltMin}"><code>short_lex</code></a>, <a href="#CoxeterGroups.inverse_short_lex-Tuple{CoxEltMin}"><code>inverse_short_lex</code></a>, <a href="#Base.:*-Tuple{CoxEltMin, CoxEltMin}"><code>*</code></a>, <a href="#Base.inv-Tuple{CoxEltMin}"><code>inv</code></a>, <a href="#Base.:^-Tuple{CoxElt, Integer}"><code>^</code></a>.</li></ul><h2 id="Code-conventions"><a class="docs-heading-anchor" href="#Code-conventions">Code conventions</a><a id="Code-conventions-1"></a><a class="docs-heading-anchor-permalink" href="#Code-conventions" title="Permalink"></a></h2><p>Code conventions are (currently) as follows:</p><ul><li>Library users should access data via methods, not via properties.</li><li>A Coxeter group implementation called <code>foo</code> should define a concrete subtype <code>CoxGrpFoo</code> of <code>CoxGrp</code>, and a concrete subtype <code>CoxEltFoo</code> of <code>CoxElt</code>.</li></ul><h2 id="Mathematical-conventions"><a class="docs-heading-anchor" href="#Mathematical-conventions">Mathematical conventions</a><a id="Mathematical-conventions-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-conventions" title="Permalink"></a></h2><p>A <em>generalised Cartan matrix</em> or <em>GCM</em> is a square matrix <span>$A \in \operatorname{Mat}_I(\mathbb{Z})$</span> over the integers which satisfies the following properties:</p><ul><li><em>(C1)</em> All diagonal elements are equal to <span>$2$</span>,</li><li><em>(C2)</em> All off-diagonal entries are zero or negative, and</li><li><em>(C3)</em> <span>$A_{ij} = 0$</span> if and only if <span>$A_{ji} = 0$</span>.</li></ul><p>A <em>Coxeter-Cartan matrix</em> is a square matrix <span>$A$</span> over the reals which satisfies the conditions C1, C2, C3 of a GCM, and additionally</p><ul><li><em>(C4)</em> The product <span>$A_{ij} A_{ji}$</span> is either equal to <span>$4 \cos^2(\pi/m)$</span> for some <span>$m \in \{2, 3, \ldots\}$</span>, or <span>$A_{ij} A_{ji} \geq 4$</span>.</li></ul><p>A <em>based root datum</em> over the PID <span>$R$</span> (we will only be thinking of <span>$R = \mathbb{Z}$</span> or <span>$R = \mathbb{R}$</span>) is the data of:</p><ul><li>Two free <span>$R$</span>-modules <span>$X$</span> and <span>$X^\vee$</span>,</li><li>A perfect pairing <span>$\langle -, - \rangle \colon X^\vee \times X \to R$</span>,</li><li>A collection of <em>simple roots</em> <span>$\Delta = \{\alpha_i\}_{i \in I} \in X$</span>,</li><li>A collection of <em>simple coroots</em> <span>$\Delta^\vee = \{\alpha_i^\vee\}_{i \in I} \in X^\vee$</span>,</li></ul><p>such that the matrix <span>$A_{ij} := \langle \alpha_i^\vee, \alpha_j \rangle$</span> is a GCM. We then say that the based root datum is a <em>realisation</em> of the GCM <span>$A$</span>. Define the reflections <span>$r_i \colon X \to X$</span> and <span>$r_i^\vee \colon X^\vee \to X^\vee$</span> by the formulas</p><p class="math-container">\[r_i(\lambda) = \lambda - \langle \alpha_i^\vee, \lambda \rangle \alpha_i, \quad
r_i^\vee(\nu) = \nu - \langle \nu, \alpha_i \rangle \alpha_i^\vee.\]</p><p>Then the reflections each define a faithful representation of a Coxeter group <span>$(W, I)$</span> on each of <span>$X$</span> and <span>$X^\vee$</span>, which are dual in the sense that <span>$\langle w \nu, \lambda \rangle = \langle \nu, w \lambda \rangle$</span>.</p><p>Every GCM <span>$A$</span> admits two canonical based root data. The <em>simply-connected</em> realisation is the root datum where <span>$X^\vee$</span> is the free <span>$R$</span>-module with basis <span>$(\alpha_i^\vee)_{i \in I}$</span>, <span>$X = \operatorname{Hom}(X^\vee, R)$</span> is the dual, the pairing <span>$\langle -, - \rangle$</span> is the canonical pairing between a module and its dual, and the simple roots <span>$\alpha_i$</span> are uniquely determined by the condition that <span>$\langle \alpha_i^\vee, \alpha_j \rangle = A_{ij}$</span>. The <em>adjoint</em> realisation is the dual of the simply-connected realisation.</p><p>In the reflection representation implementation, we use the adjoint realisation of a GCM. Concretely, the space <span>$X$</span> is the space of column vectors, with each simple root <span>$\alpha_i$</span> a coordinate vector, the space <span>$X^\vee$</span> is the space of row vectors, with each simple coroot <span>$\alpha_i^\vee$</span> equal to the <span>$i$</span>th row of the Cartan matrix, and the pairing <span>$\langle -, - \rangle$</span> is the dot product.</p><h2 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h2><h3 id="Minimal-roots-implementation"><a class="docs-heading-anchor" href="#Minimal-roots-implementation">Minimal roots implementation</a><a id="Minimal-roots-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-roots-implementation" title="Permalink"></a></h3><p>The <em>minimal roots</em> implementation of a Coxeter group represents group elements by words in the Coxeter generators in ShortLex normal form. Operations on these words are done with the assistance of a <em>minimal root reflection table</em>, which needs to be constructed when the group is created.</p><p>Currently this implementation can handle any Coxeter group defined by a generalised Cartan matrix, but this is only because generating the minimal root reflection table is more difficult for general Coxeter groups. The same underlying algorithms will work once given a new table.</p><p>Performance characteristics for a Coxeter group of rank <span>$r$</span>:</p><ul><li>The group itself takes <span>$O(r M)$</span> space, where <span>$M$</span> is the number of minimal roots. For finite types, the minimal roots are exactly the positive roots, and for affine types, there are twice as many minimal roots as there are positive roots for the corresponding finite system. The number of roots in a finite system tends to be <span>$O(r^2)$</span> in the rank <span>$r$</span>.</li><li>Length is an <span>$O(1)$</span> operation.</li><li>ShortLex normal form should be <span>$O(1)$</span>, but is <span>$O(l(w))$</span> since it returns a defensive copy of the internal word.</li><li>Testing a left or right descent is <span>$O(l(w))$</span>.</li><li>Multiplication on the right <span>$xs$</span> by a simple generator <span>$s$</span> is <span>$O(l(x))$</span>.</li><li>Multiplication on the left <span>$sx$</span> by a simple generator <span>$s$</span> is <span>$O(l(x)^2)$</span>.</li><li>Multiplication <span>$xy$</span> is <span>$O(l(y)(l(x) + l(y)))$</span>.</li><li>Inversion <span>$x^{-1}$</span> is <span>$O(l(x)^2)$</span>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.CoxGrpMin" href="#CoxeterGroups.CoxGrpMin"><code>CoxeterGroups.CoxGrpMin</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A Coxeter group, implemented using the minimal root reflection table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.create_reflection_table_gcm" href="#CoxeterGroups.create_reflection_table_gcm"><code>CoxeterGroups.create_reflection_table_gcm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_reflection_table_gcm(gcm)</code></pre><p>Create the minimal root reflection table for a Coxeter group defined by a GCM (generalised Cartan matrix). This is a straightforward algorithm since we need only deal with integers, rather than algebraic integers.</p><p>The return value is a matrix <code>refl_table</code> of size R×T, where R is the rank of the group (the size of the square GCM), and T is the number of minimal roots. The minimal roots are indexed from 1:T, with the first 1:R of them corresponding to the simple roots, and the other indices arbitrary.</p><p>If <span>$β = s(α)$</span> is a minimal root, then <code>refl_table[s, α]</code> stores the index of β, and otherwise <code>refl_table[s, α] = 0</code>. Note that <code>refl_table[s, s] = 0</code> for every simple root <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxGrpMin.jl#L319-L331">source</a></section></article><h3 id="Symmetric-groups"><a class="docs-heading-anchor" href="#Symmetric-groups">Symmetric groups</a><a id="Symmetric-groups-1"></a><a class="docs-heading-anchor-permalink" href="#Symmetric-groups" title="Permalink"></a></h3><p>The symmetric group <span>$S_n$</span> on <span>$n$</span> letters is the group of permutations of the set <span>$[n] = \{1, \ldots, n\}$</span>, whose standard Coxeter generators are <span>$s_1, \ldots, s_{n-1}$</span> where <span>$s_i = (i, i+1)$</span> is an adjacent transposition. The symmetric group may be constructed using the <a href="#CoxeterGroups.symmetric_group"><code>symmetric_group</code></a> function.</p><p>A permutation <span>$\pi \colon [n] \to [n]$</span> is represented as a pair of arrays recording both <span>$\pi$</span> and its inverse <span>$\pi^{-1}$</span>:</p><p class="math-container">\[    \pi \mapsto (\mathtt{fwd} = [\pi(1), \ldots, \pi(n)], \mathtt{inv} = [\pi^{-1}(1), \ldots, \pi^{-1}(n)]).\]</p><p>Complexity of operations in terms of <span>$n$</span>:</p><ul><li>Creation of the group is <span>$O(1)$</span>.</li><li>Memory usage for each element is <span>$O(n)$</span>.</li><li>Testing a left or right descent is <span>$O(1)$</span>.</li><li>Multiplication is <span>$O(n)$</span>.</li><li>Calculating the sign of a permutation is <span>$O(n)$</span></li><li>Taking Coxeter length takes <span>$O(n^2)$</span> time (this could be improved to <span>$O(n \log n)$</span> by a standard divide-and-conquer trick to count inversions).</li></ul><h2 id="Creating-Coxeter-systems"><a class="docs-heading-anchor" href="#Creating-Coxeter-systems">Creating Coxeter systems</a><a id="Creating-Coxeter-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-Coxeter-systems" title="Permalink"></a></h2><p>A <em>Coxeter system</em> is an object which stores a Coxeter matrix along with a classification into components of known type. Currently all finite and affine type components are classified, but anything indefinite (hyperbolic or otherwise) will be classified as <code>Unknown</code> type. Some properties of finite-type Coxeter systems can be inferred entirely from this classification, without having to construct a group object at all. For instance:</p><pre><code class="language-julia hljs">using CoxeterGroups
gcm = [
     2  -1   0   0
    -1   2  -1   0
     0  -2   2   0
     0   0   0   2
]
cox = coxeter_system(gcm)
cox</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Coxeter system (rank 4, reducible, finite type) of type C3 x A1</code></pre><p>Data known purely by classification can then be queried:</p><pre><code class="language-julia hljs">rank(cox), coxeter_name(cox), number_of_reflections(cox), order(cox)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4, &quot;C3 x A1&quot;, 10, 96)</code></pre><p>The construction methods and information methods that work with Coxeter systems is below:</p><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.coxeter_system" href="#CoxeterGroups.coxeter_system"><code>CoxeterGroups.coxeter_system</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coxeter_system(mat)</code></pre><p>Create a Coxeter system from a Coxeter matrix or Cartan matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L519-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.coxeter_name-Tuple{CoxeterSystem}" href="#CoxeterGroups.coxeter_name-Tuple{CoxeterSystem}"><code>CoxeterGroups.coxeter_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coxeter_name(cox::CoxeterSystem)</code></pre><p>A string representing the type of the system, such as &quot;H3 x A2&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L557-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.rank-Tuple{CoxeterSystem}" href="#CoxeterGroups.rank-Tuple{CoxeterSystem}"><code>CoxeterGroups.rank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rank(cox::CoxeterSystem)</code></pre><p>The rank of a Coxeter system <span>$(W, S)$</span> is the number <span>$|S|$</span> of simple generators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L550-L554">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.is_irreducible-Tuple{CoxeterSystem}" href="#CoxeterGroups.is_irreducible-Tuple{CoxeterSystem}"><code>CoxeterGroups.is_irreducible</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_irreducible(cox::CoxeterSystem)</code></pre><p>A Coxeter system <span>$(W, S)$</span> is irreducible if its associated underyling graph consists of a single connected component. In particular, <span>$|S| ≥ 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L564-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.is_finite_type-Tuple{CoxeterSystem}" href="#CoxeterGroups.is_finite_type-Tuple{CoxeterSystem}"><code>CoxeterGroups.is_finite_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_finite_type(cox::CoxeterSystem)</code></pre><p>A Coxeter system <span>$(W, S)$</span> is finite type if the group <span>$W$</span> is finite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L572-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.is_affine_type-Tuple{CoxeterSystem}" href="#CoxeterGroups.is_affine_type-Tuple{CoxeterSystem}"><code>CoxeterGroups.is_affine_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_affine_type(cox::CoxeterSystem)</code></pre><p>A Coxeter system <span>$(W, S)$</span> is affine type if is irreducible, and the unique component is of affine type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L579-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.order-Tuple{CoxeterSystem}" href="#CoxeterGroups.order-Tuple{CoxeterSystem}"><code>CoxeterGroups.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(cox::CoxeterSystem)</code></pre><p>The order of a Coxeter system <span>$(W, S)$</span> is the order of the group <span>$W$</span>. Throws an error if the system is not finite type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L612-L617">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.coxeter_number-Tuple{CoxeterSystem}" href="#CoxeterGroups.coxeter_number-Tuple{CoxeterSystem}"><code>CoxeterGroups.coxeter_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coxeter_number(cox::CoxeterSystem)</code></pre><p>The Coxeter number <span>$h$</span> of an irreducible Coxeter system <span>$(W, S)$</span> is the order of any Coxeter element (product of all simple reflections), or <span>$2 |Φ^+| / |S|$</span>, or the largest degree <span>$d_{|S|}$</span>. If the Coxeter system is not irreducible then these definitions all diverge, so this function will throw an error on a reducible system.</p><p>Throws an error if the system is reducible or not of finite type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L635-L644">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.number_of_reflections-Tuple{CoxeterSystem}" href="#CoxeterGroups.number_of_reflections-Tuple{CoxeterSystem}"><code>CoxeterGroups.number_of_reflections</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_of_reflections(cox::CoxeterSystem)</code></pre><p>The number of reflections in a Coxeter system <span>$(W, S)$</span> is the number of conjugates of the simple generators <span>$S$</span>, or equivalently the number of roots in a root system for <span>$W$</span>. Throws an error if the system is not finite type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L623-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.degrees-Tuple{CoxeterSystem}" href="#CoxeterGroups.degrees-Tuple{CoxeterSystem}"><code>CoxeterGroups.degrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">degrees(cox::CoxeterSystem)</code></pre><p>The degrees <span>$d_1 ≤ ⋯ ≤ d_r$</span> of a Coxeter system <span>$(W, S)$</span> are the degrees of the fundamental invariants for the action of <span>$W$</span> on <span>$\operatorname{Sym}(V^*)$</span>, where <span>$V$</span> is an irreducible representation of <span>$W$</span> with <span>$S$</span> acting by reflections. Throws an error if the system is not finite type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L586-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CoxeterGroups.exponents-Tuple{CoxeterSystem}" href="#CoxeterGroups.exponents-Tuple{CoxeterSystem}"><code>CoxeterGroups.exponents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exponents(cox::CoxeterSystem)</code></pre><p>The exponents <span>$m_1 ≤ ⋯ ≤ m_r$</span> of a Coxeter system <span>$(W, S)$</span> describe the eigenvalues (with multiplicity) of a Coxeter element acting on the Tits representation <span>$V$</span>, which are roots of unity <span>$\exp(2 \pi i m_i / h)$</span> where <span>$h$</span> is the Coxeter number. Throws an error if the system is not finite type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RexWzh/CoxeterGroups.jl/blob/55b8dd1d880cb85a0c81ea76569c098687a3cb95/src/CoxeterSystems.jl#L599-L606">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 15 October 2022 20:27">Saturday 15 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
